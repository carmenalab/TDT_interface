"""
TDT_control_ax.py
author: Ryan Neely
A series of functions to connect to and
read/write data to TDT bioamp processors 
*****using the TDT ActiveX controls*******.

*******************
*******************
NOTE: This set of functions works ONLY with RPvdsEx circuits and NOT(!)
with OpenEx (workbench, openController, etc). It will cause workbench to crash.
To allow access to parameter tags when using OpenEx, you need to use TDevAccX.
"""
from win32com.client import Dispatch
import numpy as np
import time


## a class for interacting with the RZ2 processor on an
##optical gigabit interface. Constructor should be passed a
##string path to the circuit that should be loaded. 
class RZ2:
	def __init__(self, circ_path):
		self.circ_path = circ_path
		self.dsp = None
		self.fs = None
		self.is_running = False

	## a function to load a circuit. Local = True loads
	##the circuit to local memory but NOT the processor.
	#start dictates whether to run the circuit on the device. 
	def load_circuit(self, local = True, start = False):
		##load the activeX controls
		proc = Dispatch('RPco.X')
		##connect to the processor 
		if proc.ConnectRZ2('GB', 1) == 0:
			raise SystemError, "Cannot connect to hardware"
		if local:
			#just load the circuit into memory but not the RZ2
			if proc.ReadCOF(self.circ_path) == 0:
				raise SystemError, "Cannot load circuit to local memory"
		else:
			#clear whatever might be loaded on the RZ2
			if proc.ClearCOF() == 0:
				raise SystemError, "Cannot clear device"
			#load circuit onto device
			if proc.LoadCOF(self.circ_path) == 0:
				raise SystemError, "Cannot load circuit to device"
		if start:
			if proc.Run() == 0:
				raise SystemError, "Cannot start circuit"
		self.dsp = proc

	#to stop the circuit
	def stop(self):
		if self.dsp.Halt() == 0:
			raise SystemError, "Cannot stop device"

	# to get the sampling frequency 
	def get_fs(self):
		if self.dsp is not None:
			self.fs = self.dsp.GetSFreq()
		else:
			print "No circuit loaded"
		return self.fs

	#to check the processor status (7 = loaded and running)
	def get_status(self):
		result = self.dsp.GetStatus()
		if result == 7:
			self.is_running = True
		return result

	##to set parameter tag values. Requires string tag_name and 
	##value to set parameter to
	def set_tag(self, tag_name, value):
		if self.dsp.SetTagVal(tag_name, value) == 0:
			raise SystemError, "Cannot set tag"

	##to get a parameter tag
	def get_tag(self, tag_name):
		if self.dsp is not None:
			result = self.dsp.GetTagVal(tag_name)
		else:
			print "No circuit loaded"
			result = None
		return result

	##to send a software trigger
	def send_trig(self, trig_num):
		if self.dsp.SoftTrg(1) == 0:
			raise SystemError, "Cannot connect to hardware"

	##to acquire a certain number of samples from the system's buffer.
	##this is NOT an ideal implementation. I tried many ways to make this work
	##with python's multiprocessing functionality, but alas no luck. The main issue
	##is that you don't want to grab the full data buffer all at once, or
	##you overload the processors. 
	#parag- the tag name (str) of the buffer to read from 
	#num_samples- total samples to read from the buffer
	#channels- number of channels being written to the buffer 
	#dtype_o- data type to read out
	#dtype_i- data type to save as 
	#poll_rate: frequency with which to grab data from the hardware buffer (seconds)
	def stream_data(self, partag, num_samples, channels, dtype_o, dtype_i, poll_rate = 0.1):
		#make sure the processor is connected, loaded and running
		if self.dsp.GetStatus() ==0:
			print "trying to reconnect"
			##try to reconnect to the processor 
			if self.dsp.ConnectRZ2('GB', 1) == 0:
				raise SystemError, "Cannot connect to hardware"
			if self.dsp.ReadCOF(self.circ_path) == 0:
				raise SystemError, "Cannot load circuit to local memory"
		#figure out the size of the data chunk to grab every loop
		sr = self.fs
		chunk_size = np.ceil(sr*poll_rate)
		##figure out the number of chunks
		num_chunks = np.ceil(num_samples/chunk_size)
		##allocate memory for the data to be read (might be larger than
		##num_samples; we'll deal with this later)
		data_stream = np.zeros((channels, num_chunks*chunk_size))
		##start saving the data
		for i in np.arange(0, num_chunks*chunk_size, chunk_size):
			time.sleep(poll_rate)
			data_stream[:,i:i+chunk_size] = np.asarray(self.dsp.ReadTagVEX(partag, i, 
				chunk_size, dtype_o, dtype_i, channels))
		##throw out any extra array pieces
		data_stream = data_stream[:,0:num_samples]
		return data_stream


##a function to parse the sort code data generated by the PC Sort macro in RPvdsEx
def parse_sorted(arr_in):
	##lookup table for unit letters to be compatible with Plexon naming convention
	unit_letters = ['a', 'b', 'c', 'd']
	##generate an output dictionary
	results_dict = {}
	##how many channels are we dealing wtih?
	num_chans = arr_in.shape[0]
	##run through each channel and parse individual sort codes
	for c in range(int(num_chans)):
		#how many units sorted on this channel?
		num_sorted = arr_in[c,:].max()
		##if the max is > 4, outlier sort codes are present- get rid of them
		while num_sorted > 4:
			#print "Removing outlier sort code ("+str(num_sorted)+")"
			np.place(arr_in[c,:], arr_in[c,:]==num_sorted, [0])
			num_sorted = arr_in[c,:].max()
		if num_sorted > 0:
			for unit in range(1,int(num_sorted+1)):
				spiketrain = (arr_in[c,:] == unit).astype(int)
				if c < 9:
					pad = '00'
				elif c < 99:
					pad = '0'
				else:
					pad = ''
				name = 'sig'+pad+str(c+1)+unit_letters[unit-1]
				results_dict[name] = spiketrain
	return results_dict


## a helper function to get the names of all the sorted units in a file set
def get_sorted_names(fIn):
	##get the names from one set as a start
	unit_names = parse_sorted(np.asarray(fIn['orientation']['set_1']['0'][0,:,:])).keys()
	##check all instances, and if there is a new addition, add it to the master list
	for setN in range(NUM_SETS):
		for oriN in DIRECTIONS:
			units_present = parse_sorted(np.asarray(fIn['orientation']['set_'+str(setN+1)][str(oriN)][0,:,:])).keys()
			for unit in units_present:
				if unit not in unit_names:
					#print "adding a unit - " + unit
					unit_names.append(unit)
	return unit_names

